# 2023년 Day 13 Advent of Code 문제 풀이

## Part 1

### 문제 설명

Part 1 문제의 목표는 여러 패턴(문자 그리드) 각각에 대해 단일 대칭선을 찾는 것입니다. 이 대칭선은 수평이거나 수직일 수 있습니다.

*   수평 대칭선이 `R`번째 행과 `R+1`번째 행 사이에 있다면 (여기서 `R`은 1부터 시작하는 인덱스), 그 값은 `R * 100`입니다.
*   수직 대칭선이 `C`번째 열과 `C+1`번째 열 사이에 있다면 (여기서 `C`는 1부터 시작하는 인덱스), 그 값은 `C`입니다.

입력으로 주어진 모든 패턴에 대해 이러한 값을 찾아 합산하는 것이 최종 목표입니다. 각 패턴에는 정확히 하나의 주된 대칭선(수평 또는 수직)이 있다고 가정합니다.

### 풀이 방법 (`part_1.py`)

제공된 `part_1.py` 코드는 다음 단계를 통해 문제를 해결합니다.

1.  **입력 데이터 처리 (`solution` 함수)**:
    *   입력은 여러 개의 패턴으로 구성되며, 각 패턴은 빈 줄로 구분됩니다.
    *   `solution` 함수는 입력을 줄 단위로 읽어 `pattern` (문자열 리스트)을 구성합니다.
    *   빈 줄을 만나거나 입력의 마지막에 도달하면, 현재까지 수집된 `pattern`에 대해 `get_max_reflex` 함수를 호출하여 점수를 계산하고, 이 점수를 총합 `answer`에 더합니다.

2.  **주요 대칭선 결정 및 점수 계산 (`get_max_reflex` 함수)**:
    *   이 함수는 주어진 `pattern`에 대해 수평 대칭과 수직 대칭 중 어느 것이 주된 대칭인지를 결정하고 해당 점수를 반환합니다.
    *   **수평 대칭 확인**: `get_reflex(pattern)`을 호출하여 수평 대칭에 대한 정보 (`row_depth`, `row_line_num`)를 얻습니다. `row_depth`는 대칭의 "깊이" 또는 "품질"을 나타내는 값이며, `row_line_num`은 대칭선 바로 위 행의 1-기반 인덱스입니다.
    *   **수직 대칭 확인**: 패턴을 전치(transpose)하여 열을 행처럼 만듭니다 (`tuple(zip(*pattern))`). 그런 다음 이 전치된 패턴에 대해 `get_reflex()`를 다시 호출하여 수직 대칭에 대한 정보 (`col_depth`, `col_line_num`)를 얻습니다.
    *   **대칭선 선택**: `row_depth`와 `col_depth`를 비교합니다. 코드는 더 "깊은" (즉, 더 많은 행/열 쌍이 완벽하게 일치하는) 대칭을 주된 대칭으로 선택합니다.
        *   만약 `row_depth > col_depth`이면, 수평 대칭이 선택되고 `row_line_num * 100`이 반환됩니다.
        *   그렇지 않으면 (즉, `col_depth >= row_depth`이면), 수직 대칭이 선택되고 `col_line_num`이 반환됩니다.

3.  **대칭 깊이 및 위치 계산 (`get_reflex` 함수)**:
    *   이 함수는 주어진 `pattern` (행들의 리스트 또는 전치 후 열들의 리스트) 내에서 "가장 좋은" 대칭선을 찾습니다.
    *   `max_reflex` 변수를 0으로 초기화하여 찾은 대칭 중 가장 깊은 대칭의 "깊이" (`delta` 값)를 저장합니다.
    *   `max_row` 변수를 0으로 초기화하여 `max_reflex`에 해당하는 대칭선의 0-기반 시작 행/열 인덱스를 저장합니다.
    *   모든 가능한 대칭선 위치를 반복하여 검사합니다. `start_row`는 (1-기반 인덱스로) 잠재적 대칭선 바로 다음 행/열을 나타냅니다. 즉, 대칭선은 `start_row-1` 행/열과 `start_row` 행/열 사이에 위치합니다.
    *   각 `start_row`에 대해, 대칭선으로부터 바깥쪽으로 확장하면서 행/열 쌍 (`pattern[start_row - 1 - delta]` 대 `pattern[start_row + delta]`)이 일치하는지 확인합니다. `delta`는 0부터 시작합니다.
    *   비교해야 할 쌍의 수는 `min(start_row, len(pattern) - start_row)`로 제한됩니다.
    *   만약 일치하지 않는 쌍이 발견되면, 해당 `start_row`는 완벽한 대칭선이 아니므로 내부 `delta` 반복을 중단합니다.
    *   만약 `delta` 값이 현재까지의 `max_reflex`보다 크면 (즉, 더 많은 연속된 쌍이 일치했음을 의미), `max_reflex`를 현재 `delta`로, `max_row`를 `start_row - 1` (0-기반 대칭선 이전 행/열 인덱스)로 업데이트합니다. `delta`는 첫 번째 일치 쌍(delta=0) 이후 추가로 일치한 쌍의 수를 나타내므로, `max_reflex`는 일치한 총 쌍의 수 - 1과 같습니다.
    *   모든 `start_row`를 검사한 후, `max_row`에 1을 더하여 1-기반 인덱스로 만듭니다.
    *   함수는 `(max_reflex, max_row)`를 반환합니다. 여기서 `max_reflex`는 가장 깊은 대칭의 깊이 점수이고, `max_row`는 해당 대칭선 이전의 행/열 개수(1-기반)입니다. 만약 어떤 대칭도 `delta > 0`을 만족시키지 못하면 (즉, 한 쌍을 초과하여 일치하는 경우가 없으면), `max_reflex`는 0으로 남고 `max_row`는 1이 됩니다(초기값 0에서 +1).

이 알고리즘은 각 패턴에서 가장 "강력한" (가장 많은 행 또는 열이 대칭적으로 일치하는) 반사 라인을 찾아 점수를 매기는 방식으로 작동합니다.
