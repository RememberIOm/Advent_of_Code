# 2023년 Day 2 Advent of Code 문제 풀이

## Part 1

### 문제 설명

Part 1에서는 일련의 게임 기록이 주어집니다. 각 게임은 여러 번의 "뽑기(draw)"로 구성되며, 각 뽑기에서는 특정 수의 빨간색, 초록색, 파란색 큐브를 보여줍니다. 문제의 목표는 주어진 각 게임이 특정 최대 큐브 수 (빨간색 12개, 초록색 13개, 파란색 14개)로 플레이 가능한지 확인하는 것입니다. 만약 한 게임의 모든 뽑기에서 각 색상의 큐브 수가 주어진 최대치를 넘지 않으면 그 게임은 "가능한" 게임입니다. 가능한 모든 게임의 ID를 합산하여 결과를 도출합니다.

### 풀이 방법 (`part_1.py`)

`part_1.py` 코드는 다음 단계를 통해 문제를 해결합니다.

1.  **입력 처리**: 각 게임 라인을 문자열로 읽어들입니다.
2.  **`cal_num(input_game)` 함수**:
    *   입력 문자열에서 게임 ID (예: "Game 5"에서 5)를 추출합니다.
    *   게임 문자열을 개별 뽑기(draw)로 분리합니다 ("; " 기준으로).
    *   각 뽑기에 대해 다음을 수행합니다:
        *   뽑기 문자열을 색상별 큐브 수로 분리합니다 (", " 기준으로). 예: "3 blue", "4 red".
        *   현재 뽑기의 색상별 큐브 수를 임시 사전에 저장합니다 (예: `{'blue': 3, 'red': 4}`).
        *   이 사전의 각 색상별 큐브 수가 문제에서 제시된 최대치 (빨강 12, 초록 13, 파랑 14)를 초과하는지 확인합니다. `dict.get("color", 0)`을 사용하여 해당 색상이 뽑기에 없으면 0으로 처리합니다.
        *   만약 어떤 색이라도 최대치를 초과하면, 해당 게임은 불가능하므로 즉시 `0`을 반환합니다.
    *   만약 게임의 모든 뽑기가 위의 조건을 통과하면 (즉, 어떤 뽑기에서도 최대치를 초과하지 않으면), 해당 게임은 가능하므로 게임 ID를 반환합니다.
3.  **결과 집계**:
    *   입력 파일의 모든 게임 라인에 대해 `cal_num` 함수를 실행하고, 반환된 값들(가능한 게임의 ID 또는 불가능한 게임의 경우 0)을 모두 합산하여 최종 결과를 출력합니다.

## Part 2

### 문제 설명

Part 2에서는 각 게임에 대해 "가능하게 만들기 위해 필요한 최소 큐브 세트"를 결정해야 합니다. 즉, 각 게임의 모든 뽑기를 통틀어 각 색상별로 관찰된 최대 큐브 수가 바로 그 게임을 가능하게 하는 데 필요한 최소 큐브 수입니다. 예를 들어, 한 게임에서 첫 번째 뽑기가 "3 blue, 4 red"이고 두 번째 뽑기가 "1 red, 2 green, 6 blue"였다면, 이 게임을 위해서는 최소 빨간색 4개, 초록색 2개, 파란색 6개의 큐브가 필요합니다.

각 게임에 대해 이 최소 큐브 세트의 "파워(power)"를 계산해야 하며, 파워는 각 색상의 최소 필요 큐브 수를 모두 곱한 값입니다 (예: `4 * 2 * 6 = 48`). 모든 게임의 파워를 합산하여 최종 결과를 도출합니다.

### 풀이 방법 (`part_2.py`)

`part_2.py` 코드는 다음 단계를 통해 문제를 해결합니다.

1.  **입력 처리**: Part 1과 동일하게 각 게임 라인을 문자열로 읽어들입니다.
2.  **`cal_num(input_game)` 함수**:
    *   게임 문자열을 개별 뽑기(draw)로 분리합니다.
    *   각 게임마다 필요한 최소 큐브 수를 저장할 사전을 초기화합니다: `game_element_dict = {"red": 0, "blue": 0, "green": 0}`.
    *   각 뽑기에 대해 다음을 수행합니다:
        *   뽑기 문자열을 색상별 큐브 수로 분리합니다.
        *   각 색상에 대해, 현재 뽑기에서 관찰된 큐브 수와 `game_element_dict`에 이미 저장된 해당 색상의 큐브 수 중 더 큰 값으로 `game_element_dict`를 업데이트합니다. (예: `game_element_dict["red"] = max(game_element_dict["red"], current_red_count)`). 이는 게임 전체에서 각 색상별로 등장한 최대 큐브 수를 추적합니다.
    *   모든 뽑기를 처리한 후, `game_element_dict`에는 해당 게임을 가능하게 하는 데 필요한 각 색상별 최소 큐브 수가 저장됩니다.
    *   이 사전의 값들 (최소 필요 빨강, 초록, 파랑 큐브 수)을 모두 곱하여 해당 게임의 "파워"를 계산합니다. `math.prod()` 함수가 사용됩니다.
    *   계산된 파워를 반환합니다.
3.  **결과 집계**:
    *   입력 파일의 모든 게임 라인에 대해 `cal_num` 함수를 실행하여 각 게임의 파워를 얻고, 이 파워들을 모두 합산하여 최종 결과를 출력합니다.
