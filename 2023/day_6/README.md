# 2023년 Day 6 Advent of Code 문제 풀이

## 공통 핵심 함수: `cal_win(time, distance)`

Part 1과 Part 2 솔루션 모두 이 함수를 핵심 로직으로 사용합니다.

*   **목적**: 단일 경주에서 이길 수 있는 방법의 수를 계산합니다.
*   **매개변수**:
    *   `time`: 경주에 주어진 총 시간.
    *   `distance`: 이겨야 할 기록 거리.
*   **로직**:
    *   장난감 보트의 속도는 버튼을 누르고 있는 시간 (`push`)에 의해 결정됩니다. 버튼을 `push` 밀리초 동안 누르면, 보트는 `push` mm/ms의 속도로 이동합니다.
    *   이동에 사용할 수 있는 남은 시간은 `time - push` 밀리초입니다.
    *   따라서, 이동한 거리는 `(time - push) * push` mm가 됩니다.
    *   함수는 `push` 값을 `0`부터 `time - 1`까지 (버튼을 누를 수 있는 모든 가능한 정수 밀리초) 반복합니다.
    *   각 `push` 지속 시간에 대해, 이동한 거리가 기록 `distance`보다 큰지 확인합니다.
    *   `sum(...)` 함수는 기록을 이기는 `push` 지속 시간의 총 개수를 계산하는 데 사용됩니다 (`True`는 합계에서 1로, `False`는 0으로 간주됨).
    *   이 특정 경주에서 이길 수 있는 총 방법의 수를 반환합니다.

## Part 1

### 문제 설명

Part 1에서는 여러 개의 경주가 주어집니다. 각 경주마다 총 시간과 현재까지의 기록 거리가 명시되어 있습니다. 목표는 각 경주에서 기록을 깰 수 있는 버튼 누르기 시간의 가짓수를 찾고, 이 가짓수들을 모두 곱한 값을 최종 답으로 하는 것입니다.

예를 들어, 시간이 7밀리초이고 기록 거리가 9mm인 경주에서, 버튼을 2밀리초 누르면 속도는 2mm/ms가 되고 남은 시간은 5밀리초이므로 10mm를 이동하여 기록을 깹니다. 가능한 모든 버튼 누르기 시간을 검토하여 기록을 깨는 경우의 수를 찾아야 합니다.

### 풀이 방법 (`part_1.py`)

1.  **입력 데이터 파싱 (`solution` 함수)**:
    *   입력 데이터는 두 줄로 구성됩니다:
        *   첫 번째 줄: "Time:      7  15   30" (경주 시간 목록)
        *   두 번째 줄: "Distance:  9  40  200" (기록 거리 목록)
    *   첫 번째 줄을 파싱하여 경주 시간의 리스트 `time_list` (예: `[7, 15, 30]`)를 생성합니다.
    *   두 번째 줄을 파싱하여 기록 거리의 리스트 `distance_list` (예: `[9, 40, 200]`)를 생성합니다.

2.  **개별 경주 처리 및 결과 집계 (`solution` 함수)**:
    *   `zip(time_list, distance_list)`를 사용하여 각 경주의 시간과 기록 거리를 짝지어 반복합니다.
    *   각 `(time, distance)` 쌍에 대해 `cal_win(time, distance)` 함수를 호출하여 해당 경주에서 이길 수 있는 방법의 수를 계산합니다.
    *   `math.prod()` 함수 (또는 직접 구현한 곱셈 로직)를 사용하여 모든 경주에서 얻은 "이기는 방법의 수"들을 곱합니다.
    *   이 최종 곱셈 결과가 답이 됩니다.

## Part 2

### 문제 설명

Part 2에서는 입력 형식이 Part 1과 동일하지만, 해석 방식이 다릅니다. 시간과 거리 줄에 있는 숫자들은 여러 개의 경주를 나타내는 것이 아니라, 실제로는 공백을 무시하고 모든 숫자를 이어붙여 단 하나의 매우 긴 경주를 나타냅니다.

예를 들어:
*   "Time: 7 15 30"은 실제 시간 `71530` 밀리초를 의미합니다.
*   "Distance: 9 40 200"은 실제 기록 거리 `940200` mm를 의미합니다.

이 단일 경주에 대해 이길 수 있는 방법의 수를 계산하는 것이 목표입니다.

### 풀이 방법 (`part_2.py`)

1.  **입력 데이터 파싱 (`solution` 함수)**:
    *   첫 번째 "Time:" 줄에서 콜론 뒷부분의 모든 숫자 문자열을 공백 없이 이어붙인 후, 정수로 변환하여 단일 `time` 변수에 저장합니다.
    *   두 번째 "Distance:" 줄도 마찬가지로 처리하여 단일 `distance` 변수에 저장합니다.

2.  **단일 경주 처리 (`solution` 함수)**:
    *   이렇게 얻은 단일 `time`과 `distance` 값을 사용하여 `cal_win(time, distance)` 함수를 호출합니다.
    *   `cal_win` 함수가 반환하는 값 (이 단일 장기 경주에서 이길 수 있는 방법의 수)이 최종 답이 됩니다.

핵심적인 경주 승리 조건 계산 로직(`cal_win` 함수)은 Part 1과 Part 2에서 동일하게 사용되며, 입력 값을 어떻게 해석하여 이 함수에 전달하는지만 다릅니다.