# 2023년 Day 3 Advent of Code 문제 풀이

## 공통 함수: `find_num(field, i, j, visited)`

Part 1과 Part 2 솔루션 모두 이 헬퍼 함수를 사용합니다.

*   **목적**: `field` 내의 특정 좌표 `(i, j)`에 있는 숫자 문자를 기준으로 전체 숫자를 추출하고, 이 숫자가 중복으로 처리되지 않도록 합니다.
*   **작동 방식**:
    1.  주어진 좌표 `(i, j)`에서 시작하여, 해당 행에서 숫자가 이어지는 양쪽 끝(머리 `h`, 꼬리 `t`)을 찾습니다.
    2.  추출된 숫자의 각 자릿수를 `visited` 배열에 `True`로 표시하여 이미 처리되었음을 나타냅니다.
    3.  만약 숫자의 어떤 자릿수라도 이미 `visited`로 표시되어 있다면, 이는 해당 숫자가 이미 다른 기호나 기어에 의해 처리되었음을 의미하므로 `0`을 반환합니다 (중복 계산 방지).
    4.  그렇지 않으면, 추출된 전체 숫자를 정수로 변환하여 반환하고, 해당 자릿수들을 `visited`에 기록합니다.

## Part 1

### 문제 설명

Part 1의 목표는 주어진 엔진 회로도에서 모든 "부품 번호"의 합을 찾는 것입니다. 부품 번호는 기호(숫자나 '.'이 아닌 문자)에 인접한(대각선 포함) 모든 숫자입니다. 한 숫자가 여러 기호에 인접하더라도 합계에는 한 번만 포함되어야 합니다.

### 풀이 방법 (`part_1.py`)

1.  **필드 패딩**:
    *   입력된 회로도(`input_field`)의 각 행 주변과 전체 필드 위아래에 `.` 문자로 패딩을 추가합니다. 이는 이후 8방향 탐색 시 경계 검사를 단순화합니다.

2.  **초기화**:
    *   `answer`를 0으로 초기화하여 부품 번호의 합계를 저장합니다.
    *   `visited` 2차원 배열을 `False`로 초기화하여 `find_num` 함수를 통해 숫자의 중복 처리를 방지합니다.

3.  **기호 중심 탐색**:
    *   패딩된 `field`의 각 셀 `(i, j)`를 순회합니다.
    *   현재 셀 `field[i][j]`가 숫자이거나 `.`이면 건너뜁니다 (기호를 찾는 중이므로).
    *   만약 `field[i][j]`가 기호라면, 해당 기호의 8개 인접 방향(대각선 포함)을 모두 검사합니다.
    *   인접한 셀 `(next_i, next_j)`에 숫자 문자가 있다면, `find_num(field, next_i, next_j, visited)` 함수를 호출하여 전체 숫자를 추출합니다.
    *   `find_num`이 반환한 값 (숫자 자체 또는 이미 방문했다면 0)을 `answer`에 더합니다.

4.  **결과**:
    *   모든 기호 주변의 부품 번호를 합산한 `answer`를 반환합니다.

## Part 2

### 문제 설명

Part 2에서는 회로도에서 모든 기어(`*` 문자)를 찾아 "기어비"를 계산해야 합니다. 기어는 정확히 두 개의 부품 번호에 인접한 `*` 문자입니다. 각 유효한 기어에 대해, 인접한 두 부품 번호를 곱하여 해당 기어의 기어비를 구합니다. 모든 기어비를 합산한 값을 최종 결과로 합니다.

### 풀이 방법 (`part_2.py`)

1.  **필드 패딩 및 초기화**: Part 1과 동일하게 필드 패딩을 수행하고, `answer`와 `visited` 배열을 초기화합니다. `visited` 배열은 `cal_num` 함수 호출 전체에 걸쳐 공유되며, 이는 한 숫자가 여러 기어에 의해 참조되더라도 첫 번째 기어에 의해서만 계산에 사용됨을 의미합니다 (또는 `find_num`에 의해 이미 방문 처리된 경우 다음 기어 계산에서는 0으로 처리됨).

2.  **기어(`*`) 중심 탐색**:
    *   패딩된 `field`의 각 셀 `(i, j)`를 순회합니다.
    *   현재 셀 `field[i][j]`가 `*` 문자가 아니면 건너뜁니다.
    *   만약 `field[i][j]`가 `*` (잠재적 기어)라면:
        *   `gear_list`라는 빈 리스트를 초기화하여 해당 `*`에 인접한 부품 번호들을 저장합니다.
        *   `*`의 8개 인접 방향을 모두 검사합니다.
        *   인접한 셀 `(next_i, next_j)`에 숫자 문자가 있다면, `find_num(field, next_i, next_j, visited)` 함수를 호출하여 전체 숫자를 추출합니다.
        *   `find_num`이 0이 아닌 유효한 숫자(즉, 아직 방문하지 않은 숫자)를 반환하면, 이 숫자를 `gear_list`에 추가합니다.
    *   특정 `*`에 대한 모든 인접 셀 검사가 끝난 후:
        *   만약 `gear_list`의 길이가 정확히 2라면 (즉, 해당 `*`가 정확히 두 개의 부품 번호에 인접해 있다면), `gear_list`에 있는 두 숫자를 곱하여 `answer`에 더합니다.

3.  **결과**:
    *   모든 유효한 기어의 기어비를 합산한 `answer`를 반환합니다.
