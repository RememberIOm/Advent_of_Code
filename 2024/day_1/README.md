# 2024년 Day 1 Advent of Code 문제 풀이

## 입력 데이터 파싱 (Part 1 및 Part 2 공통)

두 파트의 `solution` 함수는 유사한 초기 입력 파싱 단계를 공유합니다:

1.  입력 `input_data`는 각 줄에 두 개의 공백으로 구분된 숫자를 포함하는 문자열 리스트로 예상됩니다 (예: `["10 20", "5 15"]`).
2.  각 줄을 파싱하여 정수로 변환합니다.
3.  `zip(*lines)`를 사용하여 입력을 전치(transpose)합니다. 예를 들어, 입력 줄들이 `(1,2)`, `(3,4)`, `(5,6)`을 생성했다면, `zip(*lines)`는 `[(1,3,5), (2,4,6)]`을 생성합니다.
4.  결과적으로 `left_nums`는 각 줄의 첫 번째 숫자들의 리스트가 되고, `right_nums`는 각 줄의 두 번째 숫자들의 리스트가 됩니다.

## Part 1

### 문제 설명 (코드 로직 기반 해석)

Part 1의 목표는 주어진 숫자 쌍들로부터 특정 규칙에 따라 계산된 차이들의 총합을 구하는 것입니다.

### 풀이 방법 (`part_1.py`)

1.  **입력 파싱**: 위에서 설명한 공통 파싱 단계를 거쳐 `left_nums`와 `right_nums` 리스트를 생성합니다.
2.  **리스트 정렬**:
    *   `left_nums, right_nums = map(sorted, (left_nums, right_nums))`
    *   `left_nums` 리스트와 `right_nums` 리스트를 각각 독립적으로 오름차순으로 정렬합니다. 이 단계는 각 줄의 원래 숫자 쌍을 유지하지 않고, 모든 첫 번째 숫자들의 컬렉션과 모든 두 번째 숫자들의 컬렉션을 별개로 정렬한다는 점에 유의해야 합니다.
3.  **차이 계산**:
    *   정렬된 `left_nums`와 정렬된 `right_nums` 리스트를 `zip`으로 묶어, 같은 인덱스에 있는 숫자들끼리 쌍을 이룹니다.
    *   각 쌍 `(left, right)`에 대해 `abs(left - right)`를 계산하여 두 숫자 간의 절댓값 차이를 구합니다.
4.  **총합 계산**:
    *   계산된 모든 절댓값 차이들의 합을 구하여 반환합니다.

**예시 (코드 동작 기준)**:
입력이 다음과 같다고 가정:
"10 5"
"3 8"

1.  `left_nums = [10, 3]`, `right_nums = [5, 8]`
2.  정렬 후: `left_nums = [3, 10]`, `right_nums = [5, 8]`
3.  `zip` 후 쌍: `(3, 5)`, `(10, 8)`
4.  차이: `abs(3-5)=2`, `abs(10-8)=2`
5.  총합: `2 + 2 = 4`

## Part 2

### 문제 설명 (코드 로직 기반 해석)

Part 2는 `left_nums`의 각 숫자에 대해, 해당 숫자가 `right_nums` 리스트에 나타난 빈도수를 곱한 값들의 총합을 계산합니다.

### 풀이 방법 (`part_2.py`)

1.  **`appear_count(nums)` 함수**:
    *   숫자 리스트 `nums`를 입력으로 받아, 각 숫자의 빈도수를 계산하여 딕셔너리 형태로 반환합니다 (예: `nums = [1, 2, 2, 3]` -> `counts = {1:1, 2:2, 3:1}`).

2.  **`solution(input_data)` 함수**:
    *   **입력 파싱**: Part 1과 동일하게 공통 파싱 단계를 거칩니다.
    *   **리스트 정렬**: Part 1과 동일하게 `left_nums`와 `right_nums`를 각각 독립적으로 정렬합니다.
    *   **`right_nums` 빈도수 계산**:
        *   `right_counts = appear_count(right_nums)`를 호출하여 정렬된 `right_nums` 리스트에 있는 각 숫자의 빈도수를 계산합니다.
    *   **곱셈 및 총합 계산**:
        *   정렬된 `left_nums`와 정렬된 `right_nums` 리스트를 `zip`으로 묶어 순회합니다 (실제로는 `right` 값 자체는 이 단계에서 직접 사용되지 않음).
        *   각 `left` 값 (정렬된 `left_nums`의 요소)에 대해, `right_counts.get(left, 0)`을 사용하여 `left` 값이 `right_nums` 리스트에 몇 번 나타났는지 빈도수를 가져옵니다 (없으면 0).
        *   `left * 빈도수`를 계산합니다.
        *   이렇게 계산된 모든 곱셈 결과들의 합을 구하여 반환합니다.

**예시 (코드 동작 기준)**:
입력이 다음과 같다고 가정:
"10 5"
"3 8"
"10 5"

1.  `left_nums = [10, 3, 10]`, `right_nums = [5, 8, 5]`
2.  정렬 후: `left_nums = [3, 10, 10]`, `right_nums = [5, 5, 8]`
3.  `right_counts = appear_count([5, 5, 8])` 결과: `{5: 2, 8: 1}`
4.  곱셈 (정렬된 `left_nums` 기준):
    *   `left = 3`: `right_counts.get(3, 0)`은 `0`. 곱: `3 * 0 = 0`.
    *   `left = 10`: `right_counts.get(10, 0)`은 `0`. 곱: `10 * 0 = 0`.
    *   `left = 10`: `right_counts.get(10, 0)`은 `0`. 곱: `10 * 0 = 0`.
    *   (수정된 해석: `zip(left_nums, right_nums)`는 `(3,5), (10,5), (10,8)`을 생성. `left` 값만 사용)
    *   `left = 3`: `right_counts.get(3,0)`은 `0`. `3 * 0 = 0`.
    *   `left = 10`: `right_counts.get(10,0)`은 `0`. `10 * 0 = 0`.
    *   `left = 10`: `right_counts.get(10,0)`은 `0`. `10 * 0 = 0`.
    *   이 예시에서는 `left_nums`의 값들이 `right_counts`의 키에 없어 모두 0이 나옵니다. 만약 `left_nums = [5, 8, 10]` 이고 `right_nums = [5,5,8]` (정렬 후) 이고 `right_counts = {5:2, 8:1}` 이라면:
        *   `left = 5`: `right_counts.get(5,0)`은 `2`. `5 * 2 = 10`.
        *   `left = 8`: `right_counts.get(8,0)`은 `1`. `8 * 1 = 8`.
        *   `left = 10`: `right_counts.get(10,0)`은 `0`. `10 * 0 = 0`.
        *   총합: `10 + 8 + 0 = 18`.
5.  총합: 위 예시에서는 0.

**중요**: 코드의 `map(sorted, (left_nums, right_nums))` 부분은 각 줄의 원래 쌍을 유지하지 않고, 전체 왼쪽 숫자 목록과 전체 오른쪽 숫자 목록을 각각 정렬한 후 처리합니다. 이 README는 코드의 실제 동작을 기반으로 작성되었습니다.